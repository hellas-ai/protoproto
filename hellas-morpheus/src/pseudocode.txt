// Algorithm 1: Morpheus - Local variables for process p_i
// Local variables
M_i // Initially contains b_g and a 1-QC-certificate for b_g (automatically updated)
Q_i // Initially contains 1-QC-certificate for b_g (automatically updated)
view_i // Initially 0, represents the present view
slot_i(x) for x ∈ {lead, Tr} // Initially 0, represents present slot
voted_i(z, x, s, p_j) for z ∈ {0, 1, 2}, x ∈ {lead, Tr}, s ∈ N≥0, p_j ∈ Π // Initially 0
phase_i(v) for v ∈ N≥0 // Initially 0, represents the phase within the view

// Other procedures and functions
lead(v) // Leader of view v
PayloadReady_i // Set to 1 when ready to produce transaction block
MakeTrBlock_i // Sends a new transaction block to all
LeaderReady_i // Indicates whether ready to produce leader block
MakeLeaderBlock_i // Sends a new leader block to all

// Algorithm 1: Morpheus - Instructions for process p_i
// Process p_i executes the following transitions at timeslot t (according to its local clock), 
// until no further transitions apply. If multiple transitions apply simultaneously, then p_i 
// executes the first that applies, before checking whether further transitions apply, and so on.

// Update view
If there exists greatest v ≥ view_i s.t. M_i contains at least f + 1 end-view v messages then:
    Form a (v + 1)-certificate and send it to all processes;

If there exists some greatest v > view_i such that either:
    (i) M_i contains a v-certificate q, or (ii) Q_i contains q with q.view = v, then:
        Set view_i := v; Send (either) q to all processes;
        Send all tips q' of Q_i such that q'.auth = p_i to lead(v);
        Send (v, q') signed by p_i to lead(v), where q' is a maximal amongst 1-QCs seen by p_i

// Send 0-votes and 0-QCs
If M_i contains some b s.t. voted_i(0, b.type, b.slot, b.auth) = 0:
    Send a 0-vote for b (signed by p_i) to b.auth; Set voted_i(0, b.type, b.slot, b.auth) := 1;

If M_i contains a 0-quorum for some b s.t.:
    (i) b.auth = p_i, and (ii) p_i has not previously sent a 0-QC for b to other processors, then:
        Send a 0-QC for b to all processes;

// Send out a new transaction block
If PayloadReady_i = 1 then:
    MakeTrBlock_i;

// Send out a new leader block
If p_i = lead(view_i), LeaderReady_i = 1, phase_i(view_i) = 0 and Q_i does not have a single tip:
    MakeLeaderBlock_i;

// Send 1 and 2-votes for transaction blocks
If there exists b ∈ M_i with b.type = lead and b.view = view_i and
   there does not exist unfinalized b ∈ M_i with b.type = lead and b.view = view_i then:
    If there exists b ∈ M_i with b.type = Tr, b.view = view_i and which is a single tip of M_i s.t.:
        (i) b.1-QC is greater than or equal to every 1-QC in Q_i and;
        (ii) voted_i(1, Tr, b.slot, b.auth) = 0, then:
            Send a 1-vote for b to all processes; Set phase_i(view_i) := 1;
            Set voted_i(1, Tr, b.slot, b.auth) := 1;

    If there exists a 1-QC q ∈ Q_i which is a single tip of Q_i s.t.:
        (i) q.type = Tr and (ii) voted_i(2, Tr, q.slot, q.auth) = 0, then:
            If there does not exist b ∈ M_i of height greater than q.h:
                Send a 2-vote for q.b to all processes; Set phase_i(view_i) := 1;
                Set voted_i(2, Tr, q.slot, q.auth) := 1;

// Vote for a leader block
If phase(view_i) = 0:
    If ∃b ∈ M_i with b.type = lead, b.view = view_i, voted_i(1, lead, b.slot, b.auth) = 0 then:
        Send a 1-vote for b to all processes; Set voted_i(1, lead, b.slot, b.auth) := 1;
    
    If ∃q ∈ Q_i which is a 1-QC with voted_i(2, lead, q.slot, q.auth) = 0, q.type = lead,
       q.view = view_i, then:
        Send a 2-vote for q.b to all processes; Set voted_i(2, lead, q.slot, q.auth) := 1;

// Complain
If ∃q ∈ Q_i which is maximal according to ⪰ amongst those that have not been finalized for
   time 6Δ since entering view view_i:
    Send q to lead(view_i) if not previously sent;

If ∃q ∈ Q_i which has not been finalized for time 12Δ since entering view view_i:
    Send the end-view message (view_i) signed by p_i to all processes;

    // ======== Supporting Functions and Procedures for Morpheus Protocol ========

// Function to determine if a QC is a single tip
function isSingleTip(Q_i, q) -> boolean:
    Return (q ⪰ q' for all q' ∈ Q_i)
    // Where ⪰ is the observes relation defined in the paper


// Function to compare QCs by the ordering relation ≤
function compareQCs(q, q') -> int:
    // Compare by view
    If q.view < q'.view then return -1
    If q.view > q'.view then return 1
    
    // Same view, compare by type (lead < Tr)
    If q.type = lead and q'.type = Tr then return -1
    If q.type = Tr and q'.type = lead then return 1
    
    // Same view and type, compare by height
    If q.h < q'.h then return -1
    If q.h > q'.h then return 1
    
    // Equal
    Return 0
