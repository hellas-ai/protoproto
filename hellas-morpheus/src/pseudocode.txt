// Algorithm 1: Morpheus - Local variables for process p_i
// Local variables
M_i // Initially contains b_g and a 1-QC-certificate for b_g (automatically updated)
Q_i // Initially contains 1-QC-certificate for b_g (automatically updated)
view_i // Initially 0, represents the present view
slot_i(x) for x âˆˆ {lead, Tr} // Initially 0, represents present slot
voted_i(z, x, s, p_j) for z âˆˆ {0, 1, 2}, x âˆˆ {lead, Tr}, s âˆˆ Nâ‰¥0, p_j âˆˆ Î  // Initially 0
phase_i(v) for v âˆˆ Nâ‰¥0 // Initially 0, represents the phase within the view

// Other procedures and functions
lead(v) // Leader of view v
PayloadReady_i // Set to 1 when ready to produce transaction block
MakeTrBlock_i // Sends a new transaction block to all
LeaderReady_i // Indicates whether ready to produce leader block
MakeLeaderBlock_i // Sends a new leader block to all

// Algorithm 1: Morpheus - Instructions for process p_i
// Process p_i executes the following transitions at timeslot t (according to its local clock), 
// until no further transitions apply. If multiple transitions apply simultaneously, then p_i 
// executes the first that applies, before checking whether further transitions apply, and so on.

// Update view
If there exists greatest v â‰¥ view_i s.t. M_i contains at least f + 1 end-view v messages then:
    Form a (v + 1)-certificate and send it to all processes;

If there exists some greatest v > view_i such that either:
    (i) M_i contains a v-certificate q, or (ii) Q_i contains q with q.view = v, then:
        Set view_i := v; Send (either) q to all processes;
        Send all tips q' of Q_i such that q'.auth = p_i to lead(v);
        Send (v, q') signed by p_i to lead(v), where q' is a maximal amongst 1-QCs seen by p_i

// Send 0-votes and 0-QCs
If M_i contains some b s.t. voted_i(0, b.type, b.slot, b.auth) = 0:
    Send a 0-vote for b (signed by p_i) to b.auth; Set voted_i(0, b.type, b.slot, b.auth) := 1;

If M_i contains a 0-quorum for some b s.t.:
    (i) b.auth = p_i, and (ii) p_i has not previously sent a 0-QC for b to other processors, then:
        Send a 0-QC for b to all processes;

// Send out a new transaction block
If PayloadReady_i = 1 then:
    MakeTrBlock_i;

// Send out a new leader block
If p_i = lead(view_i), LeaderReady_i = 1, phase_i(view_i) = 0 and Q_i does not have a single tip:
    MakeLeaderBlock_i;

// Send 1 and 2-votes for transaction blocks
If there exists b âˆˆ M_i with b.type = lead and b.view = view_i and
   there does not exist unfinalized b âˆˆ M_i with b.type = lead and b.view = view_i then:
    If there exists b âˆˆ M_i with b.type = Tr, b.view = view_i and which is a single tip of M_i s.t.:
        (i) b.1-QC is greater than or equal to every 1-QC in Q_i and;
        (ii) voted_i(1, Tr, b.slot, b.auth) = 0, then:
            Send a 1-vote for b to all processes; Set phase_i(view_i) := 1;
            Set voted_i(1, Tr, b.slot, b.auth) := 1;

    If there exists a 1-QC q âˆˆ Q_i which is a single tip of Q_i s.t.:
        (i) q.type = Tr and (ii) voted_i(2, Tr, q.slot, q.auth) = 0, then:
            If there does not exist b âˆˆ M_i of height greater than q.h:
                Send a 2-vote for q.b to all processes; Set phase_i(view_i) := 1;
                Set voted_i(2, Tr, q.slot, q.auth) := 1;

// Vote for a leader block
If phase(view_i) = 0:
    If âˆƒb âˆˆ M_i with b.type = lead, b.view = view_i, voted_i(1, lead, b.slot, b.auth) = 0 then:
        Send a 1-vote for b to all processes; Set voted_i(1, lead, b.slot, b.auth) := 1;
    
    If âˆƒq âˆˆ Q_i which is a 1-QC with voted_i(2, lead, q.slot, q.auth) = 0, q.type = lead,
       q.view = view_i, then:
        Send a 2-vote for q.b to all processes; Set voted_i(2, lead, q.slot, q.auth) := 1;

// Complain
If âˆƒq âˆˆ Q_i which is maximal according to âª° amongst those that have not been finalized for
   time 6Î” since entering view view_i:
    Send q to lead(view_i) if not previously sent;

If âˆƒq âˆˆ Q_i which has not been finalized for time 12Î” since entering view view_i:
    Send the end-view message (view_i) signed by p_i to all processes;

    // ======== Supporting Functions and Procedures for Morpheus Protocol ========

// Function to determine if a QC is a single tip
function isSingleTip(Q_i, q) -> boolean:
    Return (q âª° q' for all q' âˆˆ Q_i)
    // Where âª° is the observes relation defined in the paper


// Function to compare QCs by the ordering relation â‰¤
function compareQCs(q, q') -> int:
    // Compare by view
    If q.view < q'.view then return -1
    If q.view > q'.view then return 1
    
    // Same view, compare by type (lead < Tr)
    If q.type = lead and q'.type = Tr then return -1
    If q.type = Tr and q'.type = lead then return 1
    
    // Same view and type, compare by height
    If q.h < q'.h then return -1
    If q.h > q'.h then return 1
    
    // Equal
    Return 0

ğ‘§-votes. For ğ‘§ âˆˆ {0,1,2}, a ğ‘§-vote for the block ğ‘ is a message of the form (ğ‘§,ğ‘.type,ğ‘.view,
ğ‘.h,ğ‘.auth,ğ‘.slot,ğ»(ğ‘)), signed by some process in Î . The reason votes include more information
than just the hash of the block is explained in Section 4. A ğ‘§-quorum for ğ‘is a set of ğ‘›âˆ’ğ‘“ ğ‘§-votes
for ğ‘, each signed by a different process in Î . A ğ‘§-QC for ğ‘is the message ğ‘š= (ğ‘§,ğ‘.type,ğ‘.view,
ğ‘.h,ğ‘.auth,ğ‘.slot,ğ»(ğ‘))together with a threshold signature for ğ‘š, formed from a ğ‘§-quorum for ğ‘
using the threshold signature scheme.
QCs. By a QC for the block ğ‘, we mean a ğ‘§-QC for ğ‘, for some ğ‘§ âˆˆ{0,1,2}. If ğ‘is a ğ‘§-QC for ğ‘, then
we set ğ‘.b= ğ‘, ğ‘.z = ğ‘§, ğ‘.type= ğ‘.type, ğ‘.view= ğ‘.view,ğ‘.h= ğ‘.h, ğ‘.auth= ğ‘.auth, ğ‘.slot= ğ‘.slot.

We define a preordering â‰¤on QCs as follows: QCs are preordered first by view, then by type with
lead < Tr, and then by height.3
The variable ğ‘€ğ‘– . Each process ğ‘ğ‘– maintains a local variable ğ‘€ğ‘– , which is automatically updated
and specifies the set of all received messages. Initially, ğ‘€ğ‘– contains ğ‘ğ‘” and a 1-QC for ğ‘ğ‘”.
Transaction blocks. Each transaction block ğ‘is entirely specified by the following values:
â€¢ğ‘.type= Tr, ğ‘.view= ğ‘£ âˆˆNâ‰¥0, ğ‘.h= â„ âˆˆN>0, ğ‘.slot= ğ‘  âˆˆNâ‰¥0.
â€¢ğ‘.auth âˆˆÎ : the block creator.
â€¢ğ‘.Tr: a sequence of transactions.
â€¢ğ‘.prev: a non-empty set of QCs for blocks of height < â„.
â€¢ğ‘.1-QC: a 1-QC for a block of height < â„.
If ğ‘.prev contains a QC for ğ‘â€², then we say that ğ‘points to ğ‘â€². For ğ‘to be valid, we require that it is
of the form above and:
(1) ğ‘is signed by ğ‘.auth.
(2) If ğ‘  > 0, ğ‘points to ğ‘â€²with ğ‘â€²
.type= Tr, ğ‘â€²
.auth= ğ‘.auth and ğ‘â€²
.slot= ğ‘ âˆ’1.
(3) If ğ‘points to ğ‘â€², then ğ‘â€²
.view â‰¤ğ‘.view.
(4) If â„â€²
= max{ğ‘â€²
.h : ğ‘points to ğ‘â€²}, then â„= â„â€²+1.
We suppose correct processes ignore transaction blocks that are not valid. In what follows we
therefore adopt the convention that, by a â€˜transaction blockâ€™, we mean a â€˜valid transaction blockâ€™.
A comment on transaction blocks. During periods of high throughput, a transaction block
produced by ğ‘ğ‘– for slot ğ‘ will just point to ğ‘ğ‘– â€™s transaction block for slot ğ‘ âˆ’1. During periods
of low throughput, if there is a unique block ğ‘â€²received by ğ‘ğ‘– that does not conflict with
any other block received by ğ‘ğ‘– , any transaction block ğ‘produced by ğ‘ğ‘– will also point to ğ‘â€²
(so that ğ‘does not conflict with ğ‘â€²).
The use of ğ‘.1-QC is as follows: once correct ğ‘ğ‘– sees a 1-QC ğ‘, it will not vote for any
transaction block ğ‘unless ğ‘.1-QC is greater than or equal to ğ‘. Ultimately, this will be used
to argue that consistency is satisfied.
When blocks observe each other. The genesis block observes only itself. Any other block ğ‘
observes itself and all those blocks observed by blocks that ğ‘points to. If two blocks do not observe
each other, then they conflict. We write [ğ‘]to denote the set of all blocks observed by ğ‘.
The leader of view ğ‘£. The leader of view ğ‘£, denoted lead(ğ‘£), is process ğ‘ğ‘– , where ğ‘– = ğ‘£ mod ğ‘›.
End-view messages. If process ğ‘ğ‘– sees insufficient progress during view ğ‘£, it may send an end-view
ğ‘£message of the form (ğ‘£), signed by ğ‘ğ‘– . By a quorum of end-view ğ‘£messages, we mean a set of ğ‘“ +1
end-view ğ‘£ messages, each signed by a different process in Î . If ğ‘ğ‘– receives a quorum of end-view ğ‘£
messages before entering view ğ‘£+1, it will combine them (using the threshold signature scheme)
to form a (ğ‘£+1)-certificate. Upon first seeing a (ğ‘£+1)-certificate, ğ‘ğ‘– will send this certificate to all
processes and enter view ğ‘£+1. This ensures that, if some correct process is the first to enter view
ğ‘£+1 after GST, all correct processes enter that view (or a later view) within time Î”.
View ğ‘£ messages. When ğ‘ğ‘– enters view ğ‘£, it will send to lead(ğ‘£)a view ğ‘£ message of the form
(ğ‘£,ğ‘), signed by ğ‘ğ‘– , where ğ‘is a maximal amongst 1-QCs seen by ğ‘ğ‘– . We say that ğ‘is the 1-QC
corresponding to the view ğ‘£ message (ğ‘£,ğ‘).

A comment on view ğ‘£ messages. The use of view ğ‘£ messages is to carry out view changes
in the same manner as PBFT. When producing the first leader block ğ‘ of the view, the
leader must include a set of ğ‘›âˆ’ğ‘“ view ğ‘£ messages, which act as a justification for the block
proposal: the value ğ‘.1-QC must be greater than or equal all 1-QCs corresponding to those
ğ‘›âˆ’ğ‘“ view ğ‘£ messages. For each subsequent leader block ğ‘â€²produced in the view, ğ‘â€²
.1-QC
must be a 1-QC for the previous leader block (i.e., that for the previous slot). The argument
for consistency will thus employ some of the same methods as are used to argue consistency
for PBFT.
Leader blocks. Each leader block ğ‘is entirely specified by the following values:
â€¢ğ‘.type= lead, ğ‘.view= ğ‘£ âˆˆNâ‰¥0, ğ‘.h= â„ âˆˆN>0, ğ‘.slot= ğ‘  âˆˆNâ‰¥0.
â€¢ğ‘.auth âˆˆÎ : the block creator.
â€¢ğ‘.prev: a non-empty set of QCs for blocks of height < â„.
â€¢ğ‘.1-QC: a 1-QC for a block of height < â„.
â€¢ğ‘.just: a (possibly empty) set of view ğ‘£ messages.
As for transaction blocks, if ğ‘.prev contains a QC for ğ‘â€², then we say that ğ‘points to ğ‘â€². For ğ‘to be
valid, we require that it is of the form described above and:
(1) ğ‘is signed by ğ‘.auth and ğ‘.auth= lead(ğ‘£).
(2) If ğ‘points to ğ‘â€², then ğ‘â€²
.view â‰¤ğ‘.view.
(3) If â„â€²
= max{ğ‘â€²
.h : ğ‘points to ğ‘â€²}, then â„= â„â€²+1.
(4) If ğ‘  > 0, ğ‘points to a unique ğ‘âˆ—with ğ‘âˆ—
.type= lead, ğ‘âˆ—
.auth= ğ‘.auth and ğ‘âˆ—
.slot= ğ‘ âˆ’1.
(5) If ğ‘  = 0 or ğ‘âˆ—
.view < ğ‘£, then ğ‘.just contains ğ‘›âˆ’ğ‘“ view ğ‘£ messages, each signed by a different
process in Î . This set of messages is called a justification for the block.
(6) If ğ‘  = 0 or ğ‘âˆ—
.view < ğ‘£, then ğ‘.1-QC is greater than or equal to all 1-QCs corresponding to
view ğ‘£ messages in ğ‘.just.
(7) If ğ‘  > 0 and ğ‘âˆ—
.view= ğ‘£, then ğ‘.1-QC is a 1-QC for ğ‘âˆ—
.
As with transaction blocks, we suppose correct processes ignore leader blocks that are not valid. In
what follows we therefore adopt the convention that, by a â€˜leader blockâ€™, we mean a â€˜valid leader
blockâ€™.
A comment on leader blocks. The conditions for validity above are just those required to carry
out a PBFT-style approach to view changes (as discussed previously). The first leader block
of the view must include a justification for the block proposal (to guarantee consistency).
Subsequent leader blocks in the view simply include a 1-QC for the previous leader block
(i.e., that for the previous slot).
The variable ğ‘„ğ‘– . Each process ğ‘ğ‘– maintains a local variable ğ‘„ğ‘– , which is automatically updated
and, for each ğ‘§ âˆˆ{0,1,2}, stores at most one ğ‘§-QC for each block: For ğ‘§ âˆˆ{0,1,2}, if ğ‘ğ‘– receives4 a
ğ‘§-quorum or a ğ‘§-QC for ğ‘, and if ğ‘„ğ‘– does not contain a ğ‘§-QC for ğ‘, then ğ‘ğ‘– automatically enumerates
a ğ‘§-QC for ğ‘into ğ‘„ğ‘– (either the ğ‘§-QC received, or one formed from the ğ‘§-quorum received).
We define the â€˜observesâ€™ relation âª°on ğ‘„ğ‘– to be the minimal preordering satisfying (transitivity
and):
â€¢If ğ‘,ğ‘â€²âˆˆğ‘„ğ‘– , ğ‘.type= ğ‘â€²
.type, ğ‘.auth= ğ‘â€²
.auth and ğ‘.slot > ğ‘â€²
.slot, then ğ‘ âª°ğ‘â€²
.
â€¢If ğ‘,ğ‘â€²âˆˆğ‘„ğ‘– , ğ‘.type= ğ‘â€²
.type, ğ‘.auth= ğ‘â€²
.auth, ğ‘.slot= ğ‘â€²
.slot, and ğ‘.z â‰¥ğ‘â€²
.z, then ğ‘ âª°ğ‘â€²
.

We note that the observes relation âª°depends on ğ‘„ğ‘– and ğ‘€ğ‘– , and is stronger than the preordering
â‰¥we defined on ğ‘§-QCs previously, in the following sense: if ğ‘ and ğ‘â€² are ğ‘§-QCs with ğ‘ âª°ğ‘â€²
,
then ğ‘ â‰¥ğ‘â€², while the converse may not hold. When we refer to the â€˜greatestâ€™ QC in a given set,
or a â€˜maximalâ€™ QC in a given set, this is with reference to the â‰¥preordering, unless explicitly
stated otherwise. If ğ‘.type= ğ‘â€²
.type, ğ‘.auth= ğ‘â€²
.auth and ğ‘.slot= ğ‘â€²
.slot, then it will follow that
ğ‘.b= ğ‘â€²
.b.
A comment on the observes relation on ğ‘„ğ‘– . When ğ‘ğ‘– receives ğ‘,ğ‘â€² âˆˆğ‘„ğ‘– , it may not be
immediately apparent whether ğ‘.b observes ğ‘â€²
.b. The observes relation defined on ğ‘„ğ‘– above
is essentially that part of the observes relation on blocks that ğ‘ğ‘– can testify to, given the
messages it has received (while also distinguishing the â€˜levelâ€™ of the QC).
The tips of ğ‘„ğ‘– . The tips of ğ‘„ğ‘– are those ğ‘ âˆˆğ‘„ğ‘– such that there does not exist ğ‘â€²âˆˆğ‘„ğ‘– with ğ‘â€²â‰»ğ‘
(i.e. ğ‘â€²âª°ğ‘and ğ‘ âª°Ì¸ğ‘â€²). The protocol ensures that ğ‘„ğ‘– never contains more than 2ğ‘›tips: The factor 2
here comes from the fact that leader blocks produced by correct ğ‘ğ‘– need not observe all transaction
blocks produced by ğ‘ğ‘– (and vice versa).
Single tips. We say ğ‘ âˆˆğ‘„ğ‘– is a single tip of ğ‘„ğ‘– if ğ‘ âª°ğ‘â€²for all ğ‘â€²âˆˆğ‘„ğ‘– . We say ğ‘ âˆˆğ‘€ğ‘– is a single tip
of ğ‘€ğ‘– if there exists ğ‘which is a single tip of ğ‘„ğ‘– and ğ‘is the unique block in ğ‘€ğ‘– pointing to ğ‘.b.
A comment on single tips. When a transaction block is a single tip of ğ‘€ğ‘– , this will enable
ğ‘ğ‘– to send a 1-vote for the block. Leader blocks do not have to be single tips for correct
processes to vote for them.
The voted function. For each ğ‘–,ğ‘—,ğ‘ , ğ‘§ âˆˆ{0,1,2}and ğ‘¥ âˆˆ{lead,Tr}, the value votedğ‘– (ğ‘§,ğ‘¥,ğ‘ ,ğ‘ğ‘— )is
initially 0. When ğ‘ğ‘– sends a ğ‘§-vote for a block ğ‘with ğ‘.type= ğ‘¥, ğ‘.auth= ğ‘ğ‘— , and ğ‘.slot= ğ‘ , it sets
votedğ‘– (ğ‘§,ğ‘¥,ğ‘ ,ğ‘ğ‘— ):= 1. Once this value is set to 1, ğ‘ğ‘– will not send a ğ‘§-vote for any block ğ‘â€²with
ğ‘â€²
.type= ğ‘¥, ğ‘â€²
.auth= ğ‘ğ‘— , and ğ‘â€²
.slot= ğ‘ .
The phase during the view. For each ğ‘– and ğ‘£, the value phaseğ‘– (ğ‘£)is initially 0. Once ğ‘ğ‘– votes
for a transaction block during view ğ‘£, it will set phaseğ‘– (ğ‘£):= 1, and will then not vote for leader
blocks within view ğ‘£.
A comment on the phase during a view. As noted previously, each view can be thought of
as consisting of two phases. Initially, the leader is responsible for finalizing transactions.
If, after some time, the protocol enters a period of low throughput, then the leader will
stop producing leader blocks, and transactions blocks can then be finalized directly. Once
a process votes for a transaction block, it may be considered as having entered the low
throughput phase of the view. The requirement that it should not then vote for subsequent
leader blocks in the view is made so as to ensure consistency between finalized leader
blocks and transaction blocks within the view.
When blocks are final. Process ğ‘ğ‘– regards ğ‘ âˆˆğ‘„ğ‘– (and ğ‘.b) as final if there exists ğ‘â€² âˆˆğ‘„ğ‘– such
that ğ‘â€²âª°ğ‘and ğ‘is a 2-QC (for any block).